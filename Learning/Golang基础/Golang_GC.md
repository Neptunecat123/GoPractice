# Golang垃圾回收

## 垃圾回收

程序中会使用到两种内存，堆(Heap)和栈(Stack)，垃圾回收不负责回收栈中的内存。栈是一块专用内存，为了执行函数而准备，存储着函数中的局部变量和调用栈，局部变量不能被函数外访问，所以这块内存用完可以直接释放，可以通过简单的编译器指令自动清理，不需要GC算法回收。

GC只负责回收堆中的数据。C语言中需要使用malloc/free来人为申请释放堆内存。人为处理易出错造成内存泄漏，而且定位问题困难。自动化垃圾回收(garbage collection)工具就应运而生了，它可以高效的帮助程序员管理内存。

主流垃圾回收算法有，追踪式垃圾回收(Tracing garbage collection)和引用计数法(Reference counting)。三色标记法属于追踪式垃圾回收算法。

## 三色标记法原理

![Alt Text](pic/三色标记法.gif) 

追踪式算法的核心思想是判断一个对象是否可达，一旦这个对象不可达就可以立刻被GC回收。判断一个对象是否可达：第一步找出所有的全局变量和当前函数栈里的变量标记为可达；第二步，从已经标记的数据开始，进一步标记他们可访问的变量，以此类推。传递闭包。

 三色标记发的前身，Mark-And-Sweep（标记清扫），这个算法就是严格按照追踪式算法的思路来实现的。这个算法会设置一个标志位来记录对象是否被使用。最开始所有的标记位都是 0，如果发现对象是可达的就会置为 1，一步步下去就会呈现一个类似树状的结果。等标记的步骤完成后，会将未被标记的对象统一清理，再次把所有的标记位设置成 0 方便下次清理。

 这个算法最大的问题是 GC 执行期间需要把整个程序完全暂停，这样所有的对象都不会被修改了，这时候去扫描是绝对安全的。

## 三色标记法优势

我们知道Golang三色标记法中最后只剩下的黑白两种对象，黑色对象是程序恢复后接着使用的对象，如果不碰触黑色对象，只清除白色的对象，肯定不会影响程序逻辑。所以：清除操作和用户逻辑可以并发。

三色标记法最大的好处是可以异步执行，

## 三色标记法劣势

可能程序中的垃圾产生的速度会大于垃圾收集的速度，这样会导致程序中的垃圾越来越多无法被收集掉。

## Golang的GC

三色标记法+写屏障